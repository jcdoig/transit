<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 10px sans-serif;
  }
  .background {
    fill: white;
    pointer-events: all;
  }

  .loading {
    fill: black;
  }

  .menu rect {
    fill: grey;
    stroke-width: 2;
    stroke: white;
  }
  
  .selected {
    stroke: steelblue;
  }

  .route {
    stroke: grey;
  }

  .stop {
    fill: white;
    stroke: black;
    stroke-width: 1;
  }
  .map path {
    fill: none;
    stroke: grey;
    stroke-linejoin: round;
  }

  .dot {
    stroke: #000;
  }

  .interfase path {
    fill: none;
    stroke: grey;
    stroke-linejoin: round;
  }

  .interfase rect {
    fill: grey;
    stroke: white;
  }

  .interfase text {
    fill: white;
    text-anchor: middle;
  }

</style>
<body>
<script src="d3.v3.min.js"></script>
<script>
//global variables

var interval;
var svgstops;

//Data
var routes, shapes;

//Interface
var iface = {}, interfase = {} // an object to group all the interfase variables

var centered, sroute

var margin = {top: 20, right: 20, bottom: 20, left: 20},
    fullwidth = 800,
    width = fullwidth - margin.left - margin.right,
    fullheight = 600,
    height = fullheight - margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)

var busDrawInterval

iface.background = svg.append("g")

iface.map = svg.append("g").attr("class","map")
  iface.map.append("g").attr('class',"routes")
  iface.map.append("g").attr('class',"stops")
  iface.map.append("g").attr('class',"buses")

iface.background.append("rect")
    .attr("class", "background")
    .attr("width", fullwidth)
    .attr("height", fullheight)
    .on("click", click );

iface.loading = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + (margin.top - fullheight) + ")");

iface.loading.append("rect")
    .attr("class", "loading")
    .attr("width", width)
    .attr("height", height)
    .attr("rx", 10);

iface.menu = svg.append("g")
    //.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .attr("class","menu")

var button = {"spacing": 10, "size": 30}

iface.menu
  .append("g")
    .attr("transform", "translate(" + button.spacing + "," + button.spacing + ")")
  .append("rect")
    .attr("width", 2*button.spacing + button.size)
    .attr("height", 3*button.spacing + 2*button.size)
    .attr("rx", 10);

var B1 = iface.menu
  .append("g")
    .attr("transform", "translate(" + 2*button.spacing + "," + 2*button.spacing + ")")
  .append("rect")
    .attr("width", button.size)
    .attr("height", button.size)
    .attr("rx", 4);

var B2 = iface.menu
  .append("g")
    .attr("transform", "translate(" + 2*button.spacing + "," + (3*button.spacing + button.size) + ")")
  .append("rect")
    .attr("width", button.size)
    .attr("height", button.size)
    .attr("rx", 4);

var center = { x: width/2, y: height/2};

var color = d3.scale.linear()
    .domain([-500, -60, 0, 300, 2000]) //the color scale
    .range(["blue","white", "white","white", "red"]); //the colors

var lonlat = [-122.4376, 37.77];

var projection = d3.geo.mercator()
  .center(lonlat)  
  .scale(200000)
  .translate([width/2, height/2])

var xy = projection(lonlat);

var path = d3.geo.path()
  .projection(projection);

var parseDate = d3.time.format("%x_%H:%M:%S.%L_%p").parse;

var bisectL = d3.bisector(function(d) { return d.time; }).left;

function findInitialPos(events){
  var a = events[0]
  return [a.dist, a.trip, a.shape]
}

function findPos(events,time){
  var n = bisectL(events, time)
  if (events[0].time <= time && time <= events[events.length-1].time) {//todo: account for big gaps in time
    //Note that 1 needs to be subtracted from n
    var a = events[n-1]
    var b = events[n]

    return [a.dist, a.time, b.dist, b.time, a.trip, b.trip, a.shape]
  } else {  return null }   
}

function locOnPath(s_id, dist){
  var targetPath = d3.selectAll(".route")[0].filter( function(d){ 
    return d.__data__.properties.shape_id == s_id
    })[0];
  var shapeLength = targetPath.__data__.properties.l
  var pathLength = d3.select(targetPath).node().getTotalLength()
  var p = dist / shapeLength
  return d3.select(targetPath).node().getPointAtLength( p * pathLength )
}

function getBusPos(bus, time, buses){
  //console.log({"bus":bus, "time":time, "buses":buses})
  var events = buses[bus]
  var r = findPos(events, time)
  if (r === null) return
  interpDist = r[0] + ((r[2]-r[0])/(r[3]-r[1]))*(time-r[1])
  return locOnPath(r[6], interpDist)
}

function getBuses(time, buses){
  var res = {}

  // returns the list of all the buses running on the route
  // FIX THE CONDITION TO BE ACTIVE BY LOOKING AT THE TRIP ID
  d3.keys(buses).forEach(function(bus){
    var events = buses[bus]
    //console.log(events)
    var previous = -1

    events.forEach(function(event, i) {
      if (event.time <= time) {
        previous = i
      }
    })
    var next = previous + 1

    if (previous != -1 && next < events.length){
      if (events[previous].trip == events[next].trip && events[previous].dist < events[next].dist) {
      res[bus] = buses[bus]
      }
      else{
        //console.log({"p":previous, "n":next, "pt":events[previous].trip, "nt":events[next].trip})
      }
    }
    // if (p_event == undefined) {console.log({"events": events, "bus": bus, "time": time, "pos": previous(events, time)})}


    // if( previous != undefined && 
    //     next != undefined && previous.time <= time && time <= next.time && previous.trip == next.trip) {
    //   res[bus] = buses[bus]
    // }
  })
  //console.log(res)
  return res
}

function drawBuses(buses) {
  var time =  new Date("10/3/2012 08:00:00.000000 AM"); //test time
  var minute = 0;
  var sec = 0

  busDrawInterval = setInterval(function(){
      time = new Date(2012, 9, 2, 8, 0, sec+=10);
      //console.log(time)
      // get an object that contains all the current buses
      var currentBuses = getBuses(time, buses)
      //console.log('number of buses: ' + d3.keys(currentBuses).length)


      
      // remove all svg circles for buses that no longer exist

      d3.select(".buses").selectAll('circle').filter(function(bus){
        return !currentBuses[bus]
      }).remove()
      
      // update any current buses
      d3.select(".buses").selectAll('circle').each(function(bus){      
        var pos = getBusPos(bus, time, buses)
        if (pos != undefined) {
        d3.select(this)
          .transition().duration(100)
          .attr('cx', pos.x)
          .attr('cy', pos.y)
        }
        // remove this bus from the current buses so we can diff between the buses that need to be added vs the ones that are already there
        delete currentBuses[bus]
      })

      // create any new buse elements that didnt exist before
      d3.keys(currentBuses).forEach(function(bus){
        var pos = getBusPos(bus, time, buses)
        if (pos != undefined) {
        d3.select(".buses").append('circle')
          .attr('cx', pos.x)
          .attr('cy', pos.y)
          .attr('r', 3)
          .datum(bus)
        }
      })
      if (time > new Date(2012,9,5,12,0)){
        clearInterval(busDrawInterval)
      }
    }, 100)


}

function loadStops(route_id){
  d3.json("stops.json" ,function(error, data) {
    var info = data.routes.filter(function(route){ return route._id == route_id})[0].stops
    // stops.routes is an array but only contains one element
    
    d3.selectAll(".stops").selectAll("circle.stop") 
      .data(info)
      .enter()
      .append("circle")
      .attr("stroke-width", 0.5)
      .attr({
        class: "stop",
        r: 3,
        cx: function(d,i) { return projection([d.longitude, d.latitude])[0]  },
        cy:  function(d,i) { return projection([d.longitude, d.latitude])[1]  }
        })
  })
}

function loadBuses(route_id){
  // add cb
  d3.json("data/" + route_id + ".json", function(err, data){
    console.log(data)
    if(err) throw err
    var buses = data
    d3.keys(buses).forEach(function(bus){
      var events = buses[bus]
      events.forEach(function(event){
        event.time = new Date(event.time)
      })
    })
    drawBuses(buses)
    //if(cb) cb(buses)
  })
}



function selectOneRoute(route) {
  //global sroute, shapes
  
  d3.json("routes.json", function(error, data) {
    route = data.filter(function(d) { return d._id == route})[0]

    sroute = d3.selectAll(".routes").selectAll("shapes.route")
    .data(shapes.features.filter(function(d) { return route.shapes.indexOf(d.properties.shape_id) != -1 })).enter()
    .append("path")
    .attr("d", path)
    .attr("class", "selected")
    .style("stroke", "black")
    .style("stroke-width", 3)

    sroute = d3.selectAll(".routes").selectAll("shapes.route")
    .data(shapes.features.filter(function(d) { return route.shapes.indexOf(d.properties.shape_id) != -1 })).enter()
    .append("path")
    .attr("d", path)
    .attr("class", "selected")
    .style("stroke", "red")

    loadStops(route._id)
    loadBuses(route._id)
    // START LOADING THE SIMULATION
  })
}

function deselect(){}

function click(d) {
  //global iface, centered, width, height
  clearInterval(busDrawInterval)
  d3.selectAll(".selected").remove()
  d3.selectAll(".stops").selectAll("circle").remove()
  d3.selectAll(".buses").selectAll("circle").remove()

  var x, y, k, Bound, B ;
  if (d && centered !== d) {
    Bounds=[]
    d.each(function(p){ Bounds.push(path.bounds(p))})
    B = [
          [
            Math.min.apply(null,Bounds.map(function(d){return d[0][0]})),
            Math.min.apply(null,Bounds.map(function(d){return d[0][1]}))
          ], 
          [
            Math.max.apply(null,Bounds.map(function(d){return d[1][0]})),
            Math.max.apply(null,Bounds.map(function(d){return d[1][1]}))
          ]
        ]
    x = (B[0][0]+B[1][0])/2 
    y = (B[0][1]+B[1][1])/2 
    k = 0.9 *Math.min(width / (Math.abs(B[0][0]-B[1][0])), (height / (Math.abs(B[0][1]-B[1][1]))));
    centered = d;
  } else {
    x = width / 2;
    y = height / 2;
    k = 1;
    centered = null;
    deselect()
  }

  iface.map.selectAll("path")
      .classed("active", centered && function(d) { return d === centered; });

  iface.map.transition()
      .duration(1000)
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")")
      .style("stroke-width", 1.5 / k + "px");  
}





function drawAllroutes(shapes) {
  //global routes
  d3.json("routes.json", function(error, data) {
    routes = {}
    data.forEach(function(route) {
      routes[route._id] = d3.selectAll(".routes").selectAll("shapes.route")
        .data(shapes.features.filter(function(d) { return route.shapes.indexOf(d.properties.shape_id) != -1 })).enter()
        .append("path")
        .attr("d", path)
        .attr("class", "route")
        .on("mouseover", function() { routes[route._id].style("stroke-width", 3)})
        .on("mouseout", function() { routes[route._id].style("stroke-width", null)})
        .on("click", function(d) {click(routes[route._id]); selectOneRoute(route._id)})      
    })
  })
}

// ANIMATION STARTS HERE



// ENDS

function menu() {
  //global shapes
  d3.json("shapes.json", function(error, data) {
    shapes = data
    drawAllroutes(shapes)

    B1.on("mouseover", function(){d3.select(this).style("stroke-width", 5)})
      .on("mouseout", function(){d3.select(this).style("stroke-width", null)})
      .on("click", null)

    B2.on("mouseover", function(){d3.select(this).style("stroke-width", 5)})
      .on("mouseout", function(){d3.select(this).style("stroke-width", null)})
      .on("click", null)
  })
}

// START
menu()

</script>